import os
import mysql.connector
import jwt
import datetime
from mysql.connector import Error

def get_db_connection():
    try:
      port_num = int(os.getenv('DB_PORT'))
      conn = mysql.connector.connect(
          host=os.getenv('DB_HOST'),
          port=port_num,
          user=os.getenv('DB_USER'),
          password=os.getenv('DB_PASSWORD'),
          database=os.getenv('DB_NAME'),
      )
      return conn
    except Error as e:
        print(f"Error connecting to MySQL: {e}")
        return None

def find_user_by_email(email):
    conn = get_db_connection()
    if not conn:
        return None
    
    user_record = None
    try:
        cursor = conn.cursor()
        cursor.execute("SELECT UserID, PasswordHash FROM users WHERE Email = %s", (email,))
        user_record = cursor.fetchone() # Fetches one record, e.g., (1, 'some_hash_string')
    except Error as e:
        print(f"Error in find_user_by_email: {e}")
        if conn.is_connected():
            conn.rollback()
    finally:
        if conn.is_connected():
            cursor.close()
            conn.close()
    return user_record

def create_user(username, email, hashed_password):
    conn = get_db_connection()
    if not conn:
        return False
        
    success = False
    try:
        cursor = conn.cursor()
        cursor.execute("INSERT INTO users (Username, Email, PasswordHash) VALUES (%s, %s, %s)", (username, email, hashed_password))
        conn.commit()
        success = True
    except Error as e:
        print(f"Error in create_user: {e}")
        if conn.is_connected():
            conn.rollback()
    finally:
        if conn.is_connected():
            cursor.close()
            conn.close()
    return success

def get_user_profile_by_id(user_id):
    conn = get_db_connection()
    if not conn:
        return None

    user_profile = None
    try:
        cursor = conn.cursor(dictionary=True)
        cursor.execute("SELECT UserID, Username, Email, RegistrationTimestamp FROM users WHERE UserID = %s", (user_id,))
        user_profile = cursor.fetchone()
    except Error as e:
        print(f"Error in get_user_profile_by_id: {e}")
    finally:
        if conn.is_connected():
            cursor.close()
            conn.close()
    return user_profile

def create_poll(user_id, question, options):
    conn = get_db_connection()
    if not conn:
        return False

    success = False
    try:
        cursor = conn.cursor()
        cursor.execute("INSERT INTO Posts (AuthorUserID, PostType, Title) VALUES (%s, %s, %s)", (user_id, "Poll",  question))
        post_id = cursor.lastrowid
        
        for option in options:
            cursor.execute("INSERT INTO PollOptions (PostID, OptionText) VALUES (%s, %s)", (post_id, option))
        
        conn.commit()
        success = True
    except Error as e:
        print(f"Error in create_poll: {e}")
        if conn.is_connected():
            conn.rollback()
    finally:
        if conn.is_connected():
            cursor.close()
            conn.close()
    return success

def get_feed_posts(user_id):
    conn = get_db_connection()
    if not conn:
        return []

    posts = {}
    try:
        cursor = conn.cursor(dictionary=True)
        #Query partially generated by Copilot
        query = """
            SELECT 
                p.PostID, 
                p.Title,
                p.CreationTimestamp,
                p.Content,
                p.PostType,
                u.Username AS AuthorUsername,
                po.OptionID,
                po.OptionText,
                po.VoteCount
            FROM Posts p
            JOIN Users u ON p.AuthorUserID = u.UserID
            LEFT JOIN PollOptions po ON p.PostID = po.PostID
            ORDER BY p.CreationTimestamp DESC;
        """
        cursor.execute(query)
        all_post_rows = cursor.fetchall()
        
        cursor.execute("SELECT PostID FROM PollVotes WHERE UserID = %s", (user_id,))
        # Results go into a set for fast af lookups
        user_voted_polls = {row['PostID'] for row in cursor.fetchall()}
        
        cursor.execute("SELECT PostID FROM ItemVotes WHERE UserID = %s", (user_id,))
        user_voted_items = {row['PostID'] for row in cursor.fetchall()}
        
        for row in all_post_rows:
            post_id = row['PostID']
            
            if post_id not in posts:
                has_voted = False
                if row['PostType'] == 'Poll':
                    has_voted = post_id in user_voted_polls
                elif row['PostType'] == 'VoteItem':
                    has_voted = post_id in user_voted_items
                posts[post_id] = {
                    "PostID": post_id,
                    "Title": row['Title'],
                    "Content": row.get('Content', ''),  # Content may not be present for Polls
                    "PostType": row['PostType'],
                    "CreationTimestamp": row['CreationTimestamp'],
                    "AuthorUsername": row['AuthorUsername'],
                    "Options": [],
                    "userHasVoted": has_voted,
                    "priority": False  # Default priority to False
                }
            # If the current row is for a VoteItem and the user has NOT voted on it yet...
            if row['PostType'] == 'VoteItem' and not posts[post_id]['userHasVoted']:
                vote_token_payload = {
                    'user_id': user_id,
                    'post_id': post_id,
                    'purpose': 'item_vote',
                    'exp': datetime.datetime.now(datetime.timezone.utc) + datetime.timedelta(minutes=5) # Token is only valid for 5 mins
                }
                secret_key = os.getenv('SECRET_KEY')
                vote_auth_token = jwt.encode(vote_token_payload, secret_key, algorithm="HS256")
                posts[post_id]['voteAuthToken'] = vote_auth_token
                posts[post_id]['priority'] = True
                
            if row['OptionID'] is not None:
                posts[post_id]["Options"].append({
                    "OptionID": row['OptionID'],
                    "OptionText": row['OptionText'],
                    "VoteCount": row['VoteCount']
                })
    except Error as e:
        print(f"Error in collate_polls: {e}")
        return []
    finally:
        if conn.is_connected():
            cursor.close()
            conn.close()
            
    return list(posts.values())

def record_poll_vote(user_id, post_id, option_id):
    conn = get_db_connection()
    if not conn:
        return False

    success = False
    try:
        cursor = conn.cursor()
        cursor.execute("INSERT INTO PollVotes (UserID, PostID, OptionID) VALUES (%s, %s, %s)", (user_id, post_id, option_id))
        cursor.execute("UPDATE PollOptions SET VoteCount = VoteCount + 1 WHERE OptionID = %s", (option_id,))
        conn.commit()
        success = True
    except Error as e:
        print(f"Error in record_vote: {e}")
        if conn.is_connected():
            conn.rollback()
    finally:
        if conn.is_connected():
            cursor.close()
            conn.close()
    return success

def create_announcement(user_id, title, content):
    conn = get_db_connection()
    success = False
    try:
        cursor = conn.cursor()
        cursor.execute("INSERT INTO Posts (AuthorUserID, PostType, Title, Content) VALUES (%s, %s, %s, %s)", (user_id, "Announcement", title, content))
        conn.commit()
        success = True
    except Error as e:
        print(f"Error in create_announcement: {e}")
        if conn.is_connected():
            conn.rollback()
    finally:
        if conn.is_connected():
            cursor.close()
            conn.close()
    return success

# Full functionality will be added with forum sub-project later
def create_forum_topic(user_id, title, content):
    conn = get_db_connection()
    success = False
    try:
        cursor = conn.cursor()
        cursor.execute("INSERT INTO Posts (AuthorUserID, PostType, Title, Content) VALUES (%s, %s, %s, %s)", (user_id, "ForumTopic", title, content))
        conn.commit()
        success = True
    except Error as e:
        print(f"Error in create_forum_topic: {e}")
        if conn.is_connected():
            conn.rollback()
    finally:
        if conn.is_connected():
            cursor.close()
            conn.close()
    return success


def create_vote_item(user_id, title):
    conn = get_db_connection()
    if not conn:
        return False

    success = False
    try:
        cursor = conn.cursor()
        cursor.execute("INSERT INTO Posts (AuthorUserID, PostType, Title) VALUES (%s, %s, %s)", (user_id, "VoteItem", title))
        conn.commit()
        success = True
    except Error as e:
        print(f"Error in create_vote_item: {e}")
        if conn.is_connected():
            conn.rollback()
    finally:
        if conn.is_connected():
            cursor.close()
            conn.close()
    return success

def record_item_vote(user_id, post_id, choice):
    conn = get_db_connection()
    if not conn:
        return False

    success = False
    try:
        cursor = conn.cursor()
        cursor.execute("INSERT INTO ItemVotes (UserID, PostID, OptionID) VALUES (%s, %s, %s)", (user_id, post_id, choice))
        conn.commit()
        success = True
    except Error as e:
        print(f"Error in record_item_vote: {e}")
        if conn.is_connected():
            conn.rollback()
    finally:
        if conn.is_connected():
            cursor.close()
            conn.close()
    return success